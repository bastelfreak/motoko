#!/usr/bin/env ruby
# frozen_string_literal: true

# Or use Puppet's Ruby: #!/opt/puppetlabs/puppet/bin/ruby
#
# Call-seq: ./inventory.rb -F form_factor=Server -v

require 'mcollective'
require 'skittlize'
require 'terminal-table'

include MCollective::RPC # rubocop:disable Style/MixinUsage

class Node
  attr_reader :identity, :classes, :agents

  def initialize(resp)
    @identity = resp[:sender]
    @facts    = resp[:data][:facts]
    @classes  = resp[:data][:classes]
    @agents   = resp[:data][:agents]
  end

  def fact(name)
    @facts.dig(*name.to_s.split('.'))
  end
end

# rubocop:disable Layout/HashAlignment
column_specs = {
  reboot_required: { name: 'R', align: :center, proc: ->(node) { (node.fact('apt_reboot_required') || node.fact('yum_reboot_required') || node.fact('pkg_reboot_required')) ? '√' : nil } },
  host:            { proc: ->(node) { node.identity } },
  is_virtual:      { name: 'V', align: :center, proc: ->(node) { node.fact('is_virtual') ? '√' : nil } },
  cpu:             { name: 'Central Processor Unit', proc: ->(node) { format('%2d × %s', node.fact('processors.count'), node.fact('processors.models').first.gsub(/\((R|TM)\)|Processor/, '').gsub(/ {2,}/, ' ')) } },
  memory:          { fact: 'memory.system.total', align: :right },
  os:              { name: 'Operating System', proc: ->(node) { node.fact('os.distro.description') || format('%s %s', node.fact('os.name'), node.fact('os.release.full')) } },
  kernel:          { fact: 'kernelrelease' },
  puppet:          { fact: 'puppetversion' },
  odoo:            { fact: 'odoo.release.full' },
  jalios:          { fact: 'jalios.release.full' },
  nginx_vhosts:    { name: 'Virtual Hosts', proc: ->(node) { node.fact('nginx_vhosts') } },
  instance_type:   { fact: 'ec2_metadata.instance-type' },
  customer:        { proc: ->(node) { node.fact('customer') }, max_width: 20 },
}
# rubocop:enable Layout/HashAlignment

selected_columns = %i[host customer role]

options = rpcoptions do |parser, local_options|
  parser.banner = "usage: #{File.basename(__FILE__)} [options]"
  parser.define_head 'Inventory options'

  parser.on('-a', '--add-columns=COLUMNS', 'Add COLUMNS to the displayed column list', Array) do |columns|
    selected_columns += columns
  end

  parser.on('--columns=COLUMNS', 'Set the displayed column list to COLUMNS', Array) do |columns|
    selected_columns = columns
  end

  parser.on('--hw', 'Display hardware information') do
    selected_columns += %i[is_virtual cpu memory]
  end

  parser.on('--puppet', 'Display Puppet information') do
    selected_columns += %i[puppet]
  end

  parser.on('--sw', 'Display sodtware information') do
    selected_columns += %i[os kernel]
  end

  parser.on('--mono', 'Do not display a colored output') do
    local_options[:mono] = true
  end

  parser.on('-w', '--width', 'Do not ellipsis long strings') do
    local_options[:width] = true
  end

  parser.on('--[no-]count', 'Count values') do |count|
    local_options[:count] = count
  end

  parser.on('--[no-]stats', 'Display statistics') do |v|
    local_options[:stats] = v
  end

  parser.on('--sort-by=COLUMNS', 'Sort lines by COLUMS', Array) do |columns|
    local_options[:sort_by] = columns
  end
end

options[:stats] = true if options[:stats].nil?
options[:sort_by] ||= %i[customer]

selected_columns.uniq!

actual_columns = selected_columns.map do |column|
  { name: column.to_s.tr('_', ' ').gsub('.', ' > ').split.map(&:capitalize).join(' '), fact: column.to_s }.merge(column_specs[column.to_sym] || {})
end

util = rpcclient('rpcutil', options: options)
util.progress = false

util.class_filter(options[:class_filter]) if options[:class_filter]

nodes = []

util.inventory do |_, resp|
  node = Node.new(resp)

  nodes << node
end

unless nodes.empty?
  nodes.sort_by! { |a| options[:sort_by].map { |c| a.fact(c) || '' } + [a.identity] }

  nodes.map! do |node|
    actual_columns.map do |column|
      if column[:proc]
        res = column[:proc].call(node)
      elsif column[:fact]
        res = node.fact(column[:fact])
      else
        raise 'Bug'
      end

      res = res.to_s unless res.nil?

      if res.is_a?(String) && !options[:width] && column[:max_width] && res.length > column[:max_width]
        res[column[:max_width]..-1] = '…'
      end

      res
    end
  end

  nodes.skittlize! unless options[:mono]

  rows = nodes.map do |row|
    row.map do |col|
      if col.is_a?(Array)
        col.join("\n")
      else
        col
      end
    end
  end

  header = actual_columns.each_with_index.map do |column, idx|
    name = column[:name]
    if options[:count]
      different_values = rows.map { |line| line[idx] }.uniq.compact.count
      name += " (#{different_values})" if different_values > 1
    end
    {
      value: options[:mono] ? name : "\e[1m#{name}\e[0m",
      alignment: :center,
    }
  end
  table = ::Terminal::Table.new headings: header, rows: rows
  actual_columns.each_with_index do |column, idx|
    if column[:align]
      table.align_column(idx, column[:align])
    end
  end
  puts table.to_s
end

printrpcstats if options[:stats]
